#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <Streaming.h>
#include <iomanip>
#include <string>

#include <TM1638.h>
#include <TM1638QYF.h>
#include <TM1640.h>

//To fix a library error.
#undef min
#include <TM16XX.h>
#include <TM16XXFonts.h>
#include <EEPROM.h>


// -- OLED -------

// OLED i2c
#define OLED_RESET -1
#define OLED_SCREEN_I2C_ADDRESS 0x3C

#include <math.h>

//Pin variables.
const int acclerationPin = 12;
const int shootPin = 13;
const int playPin = 16;
const int ledPin = 2;
const int buzzerPin = 15;

const int moduleSTB = 1;
const int moduleCLK = 3;
const int moduleDIO = 14;

//Declaring display (game screen) and module (lives and score/high score).
Adafruit_SSD1306 display(OLED_RESET);
TM1638 module(moduleDIO, moduleCLK, moduleSTB);

//Bitmaps for menu and death screens.
const unsigned char deathBitmap [] PROGMEM = {
  // 'pixil-frame-0, 128x64px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xc0, 0xc3, 0xc3, 0x0c, 0x0f, 0xc3, 0xf3, 0xfc, 0xfc, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xc0, 0xc3, 0xc3, 0x0c, 0x0f, 0xc3, 0xf3, 0xfc, 0xfc, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xc0, 0xcc, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0x00, 0xc3, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xc0, 0xcc, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0x00, 0xc3, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0x0c, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0xf0, 0xc3, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0x0c, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0xf0, 0xc3, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0c, 0x0c, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0c, 0x0c, 0x33, 0x0c, 0x0c, 0x30, 0xc3, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0c, 0x03, 0xc0, 0xf0, 0x0f, 0xc3, 0xf3, 0xfc, 0xfc, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0c, 0x03, 0xc0, 0xf0, 0x0f, 0xc3, 0xf3, 0xfc, 0xfc, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x60, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x23, 0x80, 0x00, 0x00, 0xe0, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x04, 0x14, 0x60, 0x02, 0x00, 0x07, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0x20, 0x04, 0x00, 0x08, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x18, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x1f, 0xc0, 0x00, 0x07, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x00, 0x00, 0x78, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char menuBitmap [] PROGMEM = {
  // 'pixil-frame-0, 128x64px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0x03, 0xf3, 0xff, 0x3f, 0xcf, 0xc0, 0xf0, 0xfc, 0xfc, 0x0f, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0x03, 0xf3, 0xff, 0x3f, 0xcf, 0xc0, 0xf0, 0xfc, 0xfc, 0x0f, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0xcc, 0x00, 0x30, 0x30, 0x0c, 0x33, 0x0c, 0x30, 0xc3, 0x30, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0xcc, 0x00, 0x30, 0x30, 0x0c, 0x33, 0x0c, 0x30, 0xc3, 0x30, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0xc3, 0xc0, 0x30, 0x3f, 0x0f, 0xc3, 0x0c, 0x30, 0xc3, 0x0f, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0xc3, 0xc0, 0x30, 0x3f, 0x0f, 0xc3, 0x0c, 0x30, 0xc3, 0x0f, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0xc0, 0x30, 0x30, 0x30, 0x0c, 0xc3, 0x0c, 0x30, 0xc3, 0x00, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0xc0, 0x30, 0x30, 0x30, 0x0c, 0xc3, 0x0c, 0x30, 0xc3, 0x00, 0xc0, 0x02, 0x00, 
  0x00, 0x00, 0x30, 0xcf, 0xc0, 0x30, 0x3f, 0xcc, 0x30, 0xf0, 0xfc, 0xfc, 0x3f, 0x00, 0x02, 0x00, 
  0x00, 0x00, 0x30, 0xcf, 0xc0, 0x30, 0x3f, 0xcc, 0x30, 0xf0, 0xfc, 0xfc, 0x3f, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x39, 0x27, 0x48, 0xfa, 0x5e, 0x39, 0xee, 0x1c, 0x97, 0xdf, 0x32, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x25, 0x28, 0x48, 0x22, 0x50, 0x25, 0x09, 0x12, 0x91, 0x04, 0x4b, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x39, 0x26, 0x78, 0x23, 0xdc, 0x39, 0xc9, 0x1c, 0x91, 0x04, 0x4a, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x21, 0x21, 0x48, 0x22, 0x50, 0x29, 0x09, 0x12, 0x91, 0x04, 0x4a, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0xce, 0x48, 0x22, 0x5e, 0x25, 0xee, 0x1c, 0x61, 0x04, 0x32, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe6, 0x1c, 0x83, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x12, 0x84, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x1c, 0x87, 0x9c, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x10, 0x84, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x10, 0xf4, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
  0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
  0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 
  0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 
  0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 
  0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 
  0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 
  0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 
  0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 
  0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//Struct to represent coordinates.
struct coord {
  float x;
  float y; 
};

typedef struct coord COORD;

//Class to store information of each bullet instance.
class bullet {
  public:
  COORD coordinates;
  COORD heading;
  float velocity = 3;
};

typedef class bullet Bullet;

//Class to store information of each asteroid instance.
class asteroid {
  public:
  float radius;
  float rotation;
  COORD centre;
  COORD heading;
  COORD relPoints[8];
  bool isBaby;
};

typedef class asteroid Asteroid;

//Player variables.
float playerRot = 0;
const float accleration = .5;
const float decelerationMultiplier = .2;
float maxSpeed = 2;
float velocity = 0;
int lives = 3;
int score = 0;
int highScore = 0;
COORD playerPos = {65, 31};
COORD playerTri[3] = {};

//Array to store all on screen bullets.
Bullet bullets[8] = {};

//Array to store all on screen asteroids.
Asteroid asteroids[20] = {};

//Bool to detect whether to play game code or menu code.
bool inGame = false;

//Bool to prevent player holding shoot button.
bool shootButtonDown = false;
bool gameButtonDown = true;

void setup()
{
  //Setting up permanent memory, retrieving high score variable or 0 if not present.
  EEPROM.begin(512);
  highScore = EEPROM.get(0, highScore);
  //OLED display setup
  display.begin(SSD1306_SWITCHCAPVCC, OLED_SCREEN_I2C_ADDRESS);
  display.clearDisplay();

  //Setting up player triangle coordinate positions
  playerTri[1] = {playerPos.x, playerPos.y};
  playerTri[0] = {playerPos.x - 3, playerPos.y + 8};
  playerTri[2] = {playerPos.x + 3, playerPos.y + 8};

  //Moving all bullets in array to out of bounds location which code doesn't consider for iteration.
  for (int i = 0; i < 3; i++) {
    bullets[i].coordinates = {420, 0};
  }
  
  //Moving all asteroids in array to out of bounds location which code doesn't consider for iteration.
  for (int i = 0; i < 20; i++) {
    asteroids[i].centre = {420, 0};
  }

  //Setting up buttons
  pinMode(acclerationPin, INPUT);
  pinMode(shootPin, INPUT);
  pinMode(playPin, INPUT);

  //Setting up led indicator
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, HIGH);

  //Updating display
  setLivesDisplay();
  setScoreDisplay();
}

void loop(){

  /* Detecting if player has pressed the play button.
   * If in game, sets lives to 1 and kills the player, ending the game.
   * If not in game, puts player in game. Updates lives display.
   * Updates led indicator to match bool.
  */
  if (digitalRead(playPin) && !gameButtonDown) {
    gameButtonDown = true;
    if (inGame) {
      //Take out of game.
      lives = 1;
      playerDeath();
      inGame = false;
      setLivesDisplay();
    } else {
      inGame = true;
      setLivesDisplay();
      digitalWrite(ledPin, LOW);
    }
  }
  
  if (!digitalRead(playPin) && gameButtonDown) {
    gameButtonDown = false;
  }

  //Menu loop
  if (!inGame) {
    setScoreDisplay();
    display.clearDisplay();
    display.drawBitmap(0, 0, menuBitmap, 128, 64, WHITE);
    display.display();
    delay(100);

    //Debug button to reset high score. Keeping for demonstration and practicalness.
    if (module.getButtons() == 128) {
      highScore = 0;
      EEPROM.put(0, highScore);
      EEPROM.commit();
    }
  } else {
    //Game loop
    setScoreDisplay();

    //Grabs potentiometer value desentitised, calls rotate function.
    float sensorVal = (analogRead(A0) - 512) * -.05;
    rotate(sensorVal, playerTri);

    //Creating temporary variables for player x/y point and back centre point of triangle.
    float px = playerTri[1].x;
    float py = playerTri[1].y;
    float bx = (playerTri[0].x + playerTri[2].x) * .5;
    float by = (playerTri[0].y + playerTri[2].y) * .5;

    //Calculating gradient of 2 points.
    float slope = (py - by) / (px - bx) * -1;

    /* Modifying gradient to get radian rotation.
     * Calculates which quadrant the player is facing and configures rotation to display correct radians.
     */
    playerRot = atan(slope);
    //Quadrant player is facing
    if (px > bx && py < by) {
      // Quadrant 1
    } else if (px < bx && py < by) {
      // Quadrant 2
      playerRot = ((PI * .5) + playerRot) + (PI * .5);
    } else if (px < bx && py > by) {
      // Quadrant 3 
      playerRot += PI;
    } else if (px > bx && py > by){
      // Quadrant 4
      playerRot = (PI * 2) + playerRot;
    } // else make no changes

    //Reads player input for movement and shooting.
    bool acclerationButton = digitalRead(acclerationPin);
    bool shootButton = digitalRead(shootPin);

    //Creates header vector using cosine and sine of player rotation.
    COORD heading = {cos(playerRot), sin(playerRot)};

    //Move player based on header vector.
    if (acclerationButton) {
      velocity += accleration;
      if (velocity > maxSpeed) {
        velocity = maxSpeed;
      }
    } else {
      velocity -= accleration * decelerationMultiplier;
      if (velocity < 0) {
        velocity = 0;
      }
    }
    
    translate(velocity * heading.x, 
              velocity * heading.y * -1, 
              playerTri);

    //Begin to draw.
    display.clearDisplay();
    
    //Bullet iteration
    for (int i = 0; i < 3; i++) {
      //Out of bounds bullet reset.
      if (bullets[i].coordinates.x > 128 || bullets[i].coordinates.y > 64 ||
          bullets[i].coordinates.x < 0 || bullets[i].coordinates.y < 0) {
        bullets[i].coordinates.x = 420;
        bullets[i].coordinates.y = 0;
      }
      //Drawing in bounds bullets.
      if (bullets[i].coordinates.x != 420) {
        bullets[i].coordinates.x -= bullets[i].velocity * bullets[i].heading.x * -1;
        bullets[i].coordinates.y -= bullets[i].velocity * bullets[i].heading.y;
        display.drawPixel(bullets[i].coordinates.x, bullets[i].coordinates.y, WHITE);
      }
    }

    //Detecting if shoot button was pressed, doing this seperately as only one bullets comes out if not.
    if (shootButton && !shootButtonDown) {
      shootButtonDown = true;
      for (int i = 0; i < 3; i++) {
        if (bullets[i].coordinates.x == 420) {
        tone(buzzerPin, 4000, 30);
          bullets[i].coordinates.x = playerPos.x;
          bullets[i].coordinates.y = playerPos.y;
          bullets[i].heading.x = heading.x;
          bullets[i].heading.y = heading.y;
          break;
        }
      }
    } else if (!shootButton && shootButtonDown) {
      shootButtonDown = false;
    }
    
    //Asteroid iteration.
    for (int i = 0; i < 20; i++) {
      //Generate new asteroid if out of bounds. Only uses half of array.
      if (asteroids[i].centre.x == 420 && i < 9) {
        //As micros will be even half the time, used the modulus of it to decide where to put asteroid.
        int temp = micros();
        if (temp % 2 == 0) {
          asteroids[i].centre = {random(0, 128), -20};
        } else {
          asteroids[i].centre = {random(0, 128), 84};
        }
        //Setting variables of adult asteroid.
        asteroids[i].radius = 10;
        asteroids[i].isBaby = false;
        randomSeed(analogRead(0));
        asteroids[i].heading = {random(-100, 100) * .01, random(-100, 100) * .01};
        float radian = 0;
        for (int j = 0; j < 6; j++) {
           radian += (PI * 2) / random(5, 6);
           randomSeed(analogRead(0));
           asteroids[i].relPoints[j] = {cos(radian) * 10, sin(radian) * 10};
        }
      }

      //Move in bounds asteroids.
      if (asteroids[i].centre.x != 420) {
        asteroids[i].centre.x += asteroids[i].heading.x;
        asteroids[i].centre.y += asteroids[i].heading.y;

        //Draw asteroids.
        for (int j = 0; j < 6; j++) {
          if (j == 5) {
            display.drawLine(
              asteroids[i].relPoints[j].x + asteroids[i].centre.x,
              asteroids[i].relPoints[j].y + asteroids[i].centre.y,
              asteroids[i].relPoints[0].x + asteroids[i].centre.x,
              asteroids[i].relPoints[0].y + asteroids[i].centre.y,
              WHITE
            );
          } else {
            display.drawLine(
              asteroids[i].relPoints[j].x + asteroids[i].centre.x,
              asteroids[i].relPoints[j].y + asteroids[i].centre.y,
              asteroids[i].relPoints[j + 1].x + asteroids[i].centre.x,
              asteroids[i].relPoints[j + 1].y + asteroids[i].centre.y,
              WHITE
            );
          }
        }

        /* Check if all bullets are in range of each asteroid, one by one.
         * Could not think of a clever way to approach this.
         */
        for (int j = 0; j < 3; j++) {
          /* Checks if absolute differences in asteroid centre coords 
           * and bullet coords are lower than asteroid radius.
           */
          float temp = bullets[j].coordinates.x - asteroids[i].centre.x;
          float temp2 = bullets[j].coordinates.y - asteroids[i].centre.y;
          temp = abs(temp);
          temp2 = abs(temp2);

          //Destroys asteroid. Moves bullet and asteroid out of bounds. Adds score.
          if (temp < asteroids[i].radius && temp2 < asteroids[i].radius) {
              bullets[j].coordinates.x = 420;
              bullets[j].coordinates.y = 0;
              
              COORD originalPosition = asteroids[i].centre;
              asteroids[i].centre.x = 420;
              asteroids[i].centre.y = 0;

              if (asteroids[i].isBaby) {
                tone(buzzerPin, 3000, 90);
                score += 30;
              } else {
                tone(buzzerPin, 2000, 90);
                score += 10;
              }

              setScoreDisplay();

              //Multiplies asteroid if not a baby. Generates baby asteroids.
              if (!(asteroids[i].isBaby)) {
                int babyCount = 2;
                //Uses second half of array.
                for (int k = 10; k < 20; k++) {
                  if (asteroids[k].centre.x == 420) {
                    asteroids[k].centre = originalPosition;
                    asteroids[k].radius = 5;
                    asteroids[k].isBaby = true;
                    randomSeed(analogRead(0));
                    asteroids[k].heading = {random(-100, 100) * .03, random(-100, 100) * .03};
                    babyCount--;
        
                    float radian = 0;
                    for (int l = 0; l < 6; l++) {
                       radian += (PI * 2) / random(5, 6);
                       randomSeed(analogRead(0));
                       asteroids[k].relPoints[l] = {cos(radian) * 5, sin(radian) * 5};
                    }
                  
                  if (babyCount == 0){
                    break;
                  }
                }
              //Shot down
              }
            }
          }
        }
        //Move out of bounds asteroids to deactivated position.
        if (asteroids[i].centre.x > 158 || asteroids[i].centre.x < -28 || 
            asteroids[i].centre.y > 88 || asteroids[i].centre.y < -28) 
        {
          asteroids[i].centre.x = 420;
          asteroids[i].centre.y = 0;
        }
      }
    }

    //Draw nine triangles. Illusion of rollover.
    for (int i = 0; i < 9; i++) {
      int xoffset = 0;
      int yoffset = 0;
  
      switch (i) {
        case 0: {
          xoffset = -128;
          yoffset = -64;
          break;
        }
        case 1: {
          xoffset = 0;
          yoffset = -64;
          break;
        }
        case 2: {
          xoffset = 128;
          yoffset = -64;
          break;
        }
        case 3: {
          xoffset = -128;
          break;
        }
        case 5: {
          xoffset = 128;
          break;
        }
        case 6: {
          xoffset = -128;
          yoffset = 64;
          break;
        }
        case 7: {
          yoffset = 64;
          break;
        }
        case 8: {
          xoffset = 128;
          yoffset = 64;
          break;
        }
      }
      display.drawTriangle( playerTri[0].x + xoffset, playerTri[0].y + yoffset, 
                            playerTri[1].x + xoffset, playerTri[1].y + yoffset, 
                            playerTri[2].x + xoffset, playerTri[2].y + yoffset, WHITE);
    }    

    //Check if player is out of bounds, move their tris back to overlap drawn triangle.
    if (playerTri[0].x > 128 && playerTri[1].x > 128 && playerTri[2].x > 128) {
      translate(-128, 0, playerTri);
    }
    
    if (playerTri[0].y > 64 && playerTri[1].y > 64 && playerTri[2].y > 64) {
      translate(0, -64, playerTri);
    }
    
    if (playerTri[0].x < 0 && playerTri[1].x < 0 && playerTri[2].x < 0) {
      translate(128, 0, playerTri);
    }
    
    if (playerTri[0].y < 0 && playerTri[1].y < 0 && playerTri[2].y < 0) {
      translate(0, 64, playerTri);
    }
    
    //Check if any player tris have collided with asteroid.
    for (int i = 0; i < 3; i++) {
      bool innerLoopBreakFlag = false;
      for (int j = 0; j < 20; j++) {
        float xDiff = playerTri[i].x - asteroids[j].centre.x;
        float yDiff = playerTri[i].y - asteroids[j].centre.y;
        if (abs(xDiff) < asteroids[j].radius && abs(yDiff) < asteroids[j].radius) {
          playerDeath();
          innerLoopBreakFlag = true;
          break;
        }
      }
      
      if (innerLoopBreakFlag) {
        break;
      }
    }

    //Draw all results.
    display.display();

    /*Keep player position either on players nose, or on that relative position on screen.
     * Important to insure player can shoot when their nose appears on the other side of the screen.
     */
     
    playerPos = {wrap(0, 128, playerTri[1].x), wrap(0, 64, playerTri[1].y)};
  }
}

/* Triggers player death. Used when player collides with asteroids, 
 * or to exit the game when button is pressed.
 */
void playerDeath() {
  //Draw death bitmap and background/outline for it.
  int xBorder = 8;
  int yBorder = 4;
  display.fillRect(xBorder, yBorder, 128 - (2 * xBorder), 64 - (2 * yBorder), BLACK);
  display.drawRect(xBorder, yBorder, 128 - (2 * xBorder), 64 - (2 * yBorder), WHITE);
  display.drawBitmap(0, 0, deathBitmap, 128, 64, WHITE);
  display.display();

  //Plays death melody.
  int timeBetween = 100;
  noTone(buzzerPin);
  tone(buzzerPin, 1864, 120); //B flat - 6
  delay(120 + timeBetween);
  tone(buzzerPin, 880, 80);  //A - 5
  delay(160 + timeBetween);
  tone(buzzerPin, 415, 200); //A flat - 4
  delay(200 + timeBetween);
  tone(buzzerPin, 196, 1000); //G - 3
  delay(1000 + timeBetween);

  //Decrement lives. Set display to reflect this.
  lives--;
  setLivesDisplay();

  //End game, check if score surpasses high score, move player back to menu.
  if (lives == 0) {
    lives = 3;
    if (score > highScore) {
      highScore = score;
      EEPROM.put(0, highScore);
      EEPROM.commit();
    }
    score = 0;
    digitalWrite(ledPin, HIGH);
    inGame = false;
    setScoreDisplay();
  }

  //Move player back to starting position and redraw them.
  playerPos = {64, 32};
  
  playerTri[1] = {playerPos.x, playerPos.y};
  playerTri[0] = {playerPos.x - 3, playerPos.y + 8};
  playerTri[2] = {playerPos.x + 3, playerPos.y + 8};

  //Reset all bullets and asteroids.
  for (int i = 0; i < 3; i++) {
    bullets[i].coordinates = {420, 0};
  }
  
  for (int i = 0; i < 20; i++) {
    asteroids[i].centre = {420, 0};
  }
}

//Set module LEDs to life counter, or all on if not in game.
void setLivesDisplay() {
  int temp = 0;
  if (inGame) {
    for (int i = 0; i < lives; i++) {
      temp += pow(2, i);
    }
    module.setLEDs(temp);
  } else {
    module.setLEDs(255);
  }
}

//Set score to current score, or to high score if in the menu.
void setScoreDisplay() {
  if (inGame) {
    module.setDisplayToDecNumber(score, 0, true);
  } else {
    module.setDisplayToDecNumber(highScore, 0, true);
  }
}

//Maps floats correctly between two limits. Used to keep player position.
float wrap(float a, float b, float x) {
  if (x > a && x < b) {
    return x;
  }
  float aOffset = 0;
  float bOffset = b - a;
  float xOffset = x - a;
  
  while (true) {
    if (xOffset < aOffset) {
      xOffset += bOffset;
    } else if (xOffset > bOffset) {
      xOffset -= bOffset;
    }
    
    if (xOffset > aOffset && xOffset < bOffset) {
      return xOffset;
    }
  }
}

//Rotate player tris using a 2D transformation matrix multiplication. Discards unused dummy coords.
void rotate(float deg, COORD* playerTris) {
  float theta = deg * (PI/180);
  
  float coordMatrix[3][3] = {
    {playerTris[0].x, playerTris[0].y, 1},
    {playerTris[1].x, playerTris[1].y, 1},
    {playerTris[2].x, playerTris[2].y, 1},
  };
  
  float transformMatrix[3][3] = {
    {cos(theta), sin(theta), 0},
    {sin(theta) * -1, cos(theta), 0},
    {
      (playerTris[1].x * (1 - cos(theta))) + (playerTris[1].y * sin(theta)), 
      (playerTris[1].y * (1 - cos(theta))) - (playerTris[1].x * sin(theta)), 
      1
    } 
  };

  float finalMatrix[3][3] = {};

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      finalMatrix[i][j] = (coordMatrix[i][0] * transformMatrix[0][j]) + 
                         (coordMatrix[i][1] * transformMatrix[1][j]) +
                         (coordMatrix[i][2] * transformMatrix[2][j]);
    }
  }

  playerTris[0] = {finalMatrix[0][0], finalMatrix[0][1]};
  playerTris[1] = {finalMatrix[1][0], finalMatrix[1][1]};
  playerTris[2] = {finalMatrix[2][0], finalMatrix[2][1]};
}

//Translate player tris using a 2D transformation matrix multiplication. Discards unused dummy coords.
void translate(float x, float y, COORD* playerTris) {
  float coordMatrix[3][3] = {
    {playerTris[0].x, playerTris[0].y, 1},
    {playerTris[1].x, playerTris[1].y, 1},
    {playerTris[2].x, playerTris[2].y, 1},
  };
  
  float transformMatrix[3][3] = {
    {1, 0, 0},
    {0, 1, 0},
    {x, y, 1},
  };

  float finalMatrix[3][3] = {};

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      finalMatrix[i][j] = (coordMatrix[i][0] * transformMatrix[0][j]) + 
                         (coordMatrix[i][1] * transformMatrix[1][j]) +
                         (coordMatrix[i][2] * transformMatrix[2][j]);
    }
  }

  playerTris[0] = {finalMatrix[0][0], finalMatrix[0][1]};
  playerTris[1] = {finalMatrix[1][0], finalMatrix[1][1]};
  playerTris[2] = {finalMatrix[2][0], finalMatrix[2][1]};
}
